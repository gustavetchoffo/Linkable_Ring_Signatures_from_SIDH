

# This file was *autogenerated* from the file generalities.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7)#from sage.libs.gmp.all import mpz
from hashlib import shake_256
import random

def good_prime(d1,d2,N):
    for f in range(_sage_const_100 ):
        p=d1*d2*N*f-_sage_const_1 
        if is_prime(p) and p%_sage_const_4 ==_sage_const_3 :
            break
    return p
        
def set_seed(seed=None):
    if seed==None:
        set_random_seed()
        rseed=initial_seed()
    else: 
        set_random_seed(seed)
        rseed=seed
    return rseed

def PRNG(seed,n,d,lamda):
    Zd=IntegerModRing(d)
    set_random_seed(seed)
    a=Integer(Zd.random_element())
    rd=[ZZ.random_element(2**lamda) for _ in range(n)]
    return a,rd

def PRF(root,lamda):  
    '''Input: A lambda bits string
    output: a vector of 2 lambda bits strings'''
    import hashlib
    h= hashlib.shake_256()
    if isinstance(root, int):
        h.update(root.to_bytes(lamda//_sage_const_8 ,byteorder='big'))
    else:
        if isinstance(root, bytes):
            #print('root is bytes')
            h.update(root)
    seed=h.digest(lamda//_sage_const_4 )
    split = lamda//_sage_const_8 
    return [seed[:split], seed[split:]]

def power_of_two(a):
    vect=Integer(a).digits(_sage_const_2 )    
    vect2=[]
    vect2=[_sage_const_2 **i for i, val in enumerate(vect) if val!=_sage_const_0 ]
    vect2.reverse()
    return vect2

#.............................................................
#......... CONSTRUCTION OF Seed Tree ........................
#............................................................
class Node_seed():
    def __init__(self,value,parent=None,left_child=None,right_child=None,h=_sage_const_0 ,i=_sage_const_0 ,nb_leaves=_sage_const_1 ):
        self.value=value
        self.parent=parent
        self.left_child=left_child
        self.right_child=right_child
        self.height=h
        self.position=i
        self.nb_leaves=nb_leaves
        self.cov=False      #relevant for checking whether a node can be considered as "internal node" (releaseSeed)
    
    def set_cover(self,b=bool):
        self.cov=b
        return None
        
    def set_nb_leaves(self,nb):
        self.nb_leaves=nb
        return None
        
    def update(self,left_child,right_child,h=None,i=None,val=None):
        if val!=None:
            self.value=val
        self.left_child=left_child
        self.right_child=right_child
        if h!=None:
            self.height=h
        if i!=None:
            self.position=i
    
    def other_child(self,node):
        if self.left_child==node:
            return self.right_child
        return self.left_child
    
    def is_leaf(self):
        return self.left_child==self.right_child==None
    
    def __repr__(self):
        return f"Node of binary tree of (height, position)=({self.height},{self.position}) with value {self.value}"


class SeedTree():
    def __init__(self,root,m,lamda):
        '''construction of seed tree with m leaves and rooting at root'''
        self.root=root
        self.m=m
        self.lamda=lamda
        self.nodes={}
        self.tree(root,m)

    def leaves(self): 
        return [self.nodes[nd] for nd in self.nodes if self.nodes[nd].is_leaf()]
        
    def tree_2(self,root,t):
        ''' construct a seed tree of t leaves, rooting at self.root where t is a power of 2'''
        lamda=self.lamda
        self.nodes[root.height,root.position]=root
        if t==_sage_const_1 :
            self.nodes[root.height,root.position]=root
            return [root] 
        else:
            nb=t/_sage_const_2 
            [lc,rc]=PRF(root.value,lamda)
            height=root.height+_sage_const_1 
            pos_l=_sage_const_2 *root.position
            pos_r=_sage_const_2 *root.position+_sage_const_1 
            #print(f'({height},{pos_l})---({height},{pos_r})\n')
            left_c=Node_seed(lc,root,left_child=None,right_child=None,h=height,i=pos_l,nb_leaves=nb)
            right_c=Node_seed(rc,root,left_child=None,right_child=None,h=height,i=pos_r,nb_leaves=nb)
            self.nodes[height,pos_l]=left_c
            self.nodes[height,pos_r]=right_c
            root.update(left_c,right_c)
            return self.tree_2(left_c,nb)+self.tree_2(right_c,nb)
        
    
    def tree_T(self,root,T):
        '''Construction of seed tree of t leaves where t is the sum of t_i in T, t_i being a power of 2'''
        lamda=self.lamda
        nb=sum(T)
        root.set_nb_leaves(nb)
        self.nodes[root.height,root.position]=root
        if len(T)==_sage_const_1 :
            return self.tree_2(root,T[_sage_const_0 ])
        else:
            [lc,rc]=PRF(root.value,lamda)
            height=root.height+_sage_const_1 
            pos_l=_sage_const_2 *root.position
            pos_r=pos_l+_sage_const_1 
            left_c=Node_seed(lc,root,left_child=None,right_child=None,h=height,i=pos_l)
            right_c=Node_seed(rc,root,left_child=None,right_child=None,h=height,i=pos_r)
            root.update(left_c,right_c)
            root.left_child.set_nb_leaves(T[_sage_const_0 ])
            L=self.tree_2(root.left_child,T[_sage_const_0 ])
            T.remove(T[_sage_const_0 ])
            return L+self.tree_T(root.right_child,T)
    
    def tree(self,root,t):
        '''construct a tree of leaves rooted at root, for any t'''
        T=power_of_two(t)
        return self.tree_T(root,T)
    
    def releaseSeed(self,ch,j):
        assert len(ch)==self.m
        nodes=self.nodes
        leaves=self.leaves()
        target_leaves=[leaves[i] for i, bit in enumerate(ch) if bit == j]
        if len(target_leaves)==_sage_const_0 :
            return []
        if len(target_leaves)==_sage_const_1 :
            return [[target_leaves[_sage_const_0 ].value,target_leaves[_sage_const_0 ].nb_leaves]]
        test=all([leaf.cov for leaf in target_leaves])
        leafs=target_leaves
        while not test:
            parents=[]
            for i in range(len(leafs)):
                if leafs[i].cov:
                    parents+=[leafs[i]]
                    continue
                par=leafs[i].parent
                if par in parents:
                    continue
                if par.other_child(leafs[i]) in leafs:
                    parents+=[par]
                else:
                    leafs[i].set_cover(True)
                    parents+=[leafs[i]]
            leafs=parents  
            test=all([leaf.cov for leaf in leafs])
        int_nodes=leafs 
        #print([node.value for node in target_leaves])
        int_seeds=[[node.value,node.nb_leaves] for node in int_nodes]
        return int_seeds
             
def recover_leaves(int_seeds,ch,j,lamda):
    seeds=[]
    for s in int_seeds:
        if len(s)==_sage_const_2 :
            [val,nb]=s
            root=Node_seed(value=val,parent=None,left_child=None,right_child=None,h=_sage_const_0 ,i=_sage_const_0 ,nb_leaves=nb)
            int_tree=SeedTree(root,nb,lamda)
            leaves=int_tree.leaves()
            seeds+=[leaf.value for leaf in leaves]
        else:
            print('error')
    return seeds
    
#...................................................
#........ HACHING A DATA TO CHALLENGE SET ..........
#...................................................
def parse_hashs_t_w(d, s, t, w):
    
    '''
    IMPUT: d, a byte string digest
            s in {2,...,256}, t, w positive integers, w << t
    OUTPUT: h = [h_0, ..., h_{t-1}] in {0,..., s-1}^t with exactly w non-one elements
    We use a modified variant of Alg 9 in https://www.meds-pqc.org/spec/MEDS-2023-07-26.pdf
    '''
    
    h = [_sage_const_1 ]*t
    fb = _sage_const_0 
    bitlen_t = t.nbits()    # bit length of t
    bitlen_s = s.nbits()    # bit length of s
    bytelen_t = (bitlen_t+_sage_const_7 )//_sage_const_8 
    xof = shake_256()
    xof.update(d)

    def get_next_byte():
        nonlocal fb
        b = xof.digest(fb+_sage_const_1 )[fb]
        fb += _sage_const_1 
        return b

    # Loop to set exactly w nonzero elements
    for _ in range(w):
        while True:
            fh = _sage_const_0 
            # compute fh from next bytelen_t bytes (little endian)
            for j in range(bytelen_t):
                b_byte = get_next_byte()
                fh += b_byte << (_sage_const_8 *j)
            fh %= _sage_const_2 **bitlen_t
            if fh >= t or h[fh] != _sage_const_1 :
                continue
            # get h_fh for this location
            hfh = get_next_byte()
            hfh = hfh % (_sage_const_2 **bitlen_s)
            if hfh == _sage_const_1  or hfh >= s:
                continue
            h[fh] = hfh
            if _sage_const_0  in h and _sage_const_1  in h:
                break
    return h

